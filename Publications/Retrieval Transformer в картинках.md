**Резюме**: Новые языковые модели могут быть намного меньше GPT-3, но при этом достигать сравнимых результатов благодаря использованию запросов к базе данных или поиску информации в Интернете. Ключевая идея заключается в том, что построение все более и более крупных моделей — не единственный способ повысить качество.

Последние несколько лет ознаменовались появлением больших языковых моделей (Large Language Models, LLM) — моделей машинного обучения, которые способствовали быстрому развитию сферы машинной обработки и генерации естественного языка. Некоторые из основных вех развития области с 2017 года включают в себя:

*   Оригинальный [Трансформер](http://jalammar.github.io/illustrated-transformer/) (Transformer) бьет предыдущие рекорды качества машинного перевода.
*   [BERT](http://jalammar.github.io/illustrated-bert/) популяризирует процесс предварительного обучения, а затем тонкой настройки, а также контекстуализированные эмбеддинги слов на основе Трансформера. В скором времени он начинает использоваться в [Google Search](https://blog.google/products/search/search-language-understanding-bert/) и [Bing Search](https://azure.microsoft.com/en-us/blog/bing-delivers-its-largest-improvement-in-search-experience-using-azure-gpus/).
*   [GPT-2](http://jalammar.github.io/illustrated-gpt2/) демонстрирует способность компьютера достигать сравнимого с человеком качества написания текстов.
*   Сначала [T5](https://arxiv.org/abs/1910.10683), а затем [T0](https://huggingface.co/bigscience/T0pp) раздвигают границы трансферного обучения (обучение модели на одной задаче, а затем ее успешное применение для смежных), представляя множество различных задач в виде задачи преобразования текста в текст.
*   [GPT-3](http://jalammar.github.io/how-gpt3-works-visualizations-animations/) показала, что массовое масштабирование генеративных моделей может привести к возникновению самых удивительных приложений (и индустрия продолжает обучать все более крупные модели, такие как [Gopher](https://deepmind.com/research/publications/2021/scaling-language-models-methods-analysis-insights-from-training-gopher/), [MT-NLG](https://www.microsoft.com/en-us/research/blog/using-deepspeed-and-megatron-to-train-megatron-turing-nlg-530b-the-worlds-largest-and-most-powerful-generative-language-model/) и т. д.).

Какое-то время казалось, что масштабирование все более и более крупных моделей является основным способом повышения производительности. Недавние разработки в этой области, такие как [RETRO Transformer](https://deepmind.com/research/publications/2021/improving-language-models-by-retrieving-from-trillions-of-tokens) от DeepMind и [WebGPT](https://openai.com/blog/improving-factual-accuracy/) от OpenAI, обращают эту тенденцию вспять, показывая, что небольшие генеративные языковые модели могут работать наравне с большими, если мы дополняем их возможностью искать или запрашивать необходимую информацию.

В данной статье рассказывается о RETRO (**R**etrieval-**E**nhanced **TR**ansf**O**rmer) от DeepMind и о том, как она работает. Модель показывает результаты, сравнимые с GPT-3, несмотря на то, что она составляет всего 4% от размера последней (7.5 миллиардов параметров против 185 миллиардов у GPT-3 Da Vinci).

![](https://habrastorage.org/webt/ya/kz/ic/yakzicovhbrwj9ucr2wbo6d2oo8.png)

*RETRO использует дополнительную информацию, извлеченную из базы данных, таким образом, освобождая свои параметры от затратного хранения фактов и знаний о мире.*

RETRO была представлена в статье [Improving Language Models by Retrieving from Trillions of Tokens](https://arxiv.org/abs/2112.04426), которая основывается и, в свою очередь, продолжает широкий спектр работ исследовательского сообщества, посвященных задаче извлечения информации. Однако данная статья посвящена объяснению работы самой модели, а не тому, что нового она привнесла в данную область исследований.

# Почему это важно: отделение языковой информации от знаний о мире

Языковое моделирование обучает модели предсказывать следующее слово — по сути, заполнять пропуск в конце предложения.

Заполнение пропуска иногда требует знания фактической информации (такой как имена или даты). Например:

![](https://habrastorage.org/webt/fb/1d/0k/fb1d0kqgxnmspy5u5s9djw7rlvu.png)

*Затравка на входе: «Фильм Дюна был выпущен в ...».*

В других случаях знания языка достаточно, чтобы догадаться, что стоит на месте пропуска. Например:

![](https://habrastorage.org/webt/5-/lv/-h/5-lv-hnqpv_jonokoaenlasvwfo.png)

*Затравка на входе: «его популярность распространялась из уст в уста, чтобы позволить Герберту начать работать в полную ...».*

Это различие важно, потому что LLM закодировали все, что они знают, в своих параметрах. Хотя такая стратегия имеет смысл для языковой информации, она оказывается неэффективной для фактической информации и знании о мире.

Включение метода извлечения информации в языковую модель позволяет ей иметь намного меньший размер. Нейронная база данных помогает модели извлекать фактическую информацию, которая необходима во время генерации текста.

![](https://habrastorage.org/webt/rw/pa/ij/rwpaijumxfzf1hkqhhnsleosy6w.png)

*Поддержка языковыми моделями методов поиска позволяет уменьшить количество информации, которую они должна закодировать в своих параметрах, чтобы хорошо работать при генерации текста.*

Для небольших языковых моделей обучение становится быстрым, так как количество данных, которое необходимо запомнить, сокращается. Каждый может развернуть эти модели на меньших и более доступных графических процессорах и настроить их по мере необходимости.

Технически RETRO представляет собой модель энкодер-декодер, как и оригинальный Трансформер. Однако в RETRO входная последовательность дополняется извлеченной из базы данных информацией. Модель находит наиболее вероятные последовательности в базе данных и добавляет их на вход. Здесь происходит магия, и RETRO генерирует выходной прогноз.

![](https://habrastorage.org/webt/qw/bl/hd/qwblhdlundwsijkj9hsseqbro9m.png)

*RETRO использует базу данных для дополнения входной последовательности. Для извлечения необходимой информации из базы данных используется первоначальный текст на входе.*

Перед тем, как рассматривать архитектуру модели, давайте подробнее остановимся на базе данных.

# Исследование базы данных для извлечения информации RETRO

База данных — это хранилище ключей-значений.

Ключ представляет собой стандартный эмбеддинг предложения, полученный с помощью BERT'а.

Значение представляет собой текст, состоящий из двух частей:

*   «Сосед» (Neighbor), который используется для вычисления ключа;
*   «Завершение» (Completion), продолжение текста в исходном документе.

База данных RETRO содержит 2 триллиона многоязычных токенов на основе набора данных MassiveText. И «сосед», и «завершение» имеют длину не более 64 токенов.

![](https://habrastorage.org/webt/9e/-i/xj/9e-ixjbltfjgzfrctjo4laaumn4.png)

*Заглянув внутрь базы данных RETRO, можно увидеть примеры пар ключ-значение. Значение содержит текст «соседа» и «завершения».*

RETRO разбивает входную последовательность на несколько частей. Для простоты сосредоточимся на том, как один фрагмент дополняется извлеченным текстом. Однако модель выполняет этот процесс для каждого фрагмента (кроме первого) во входном тексте.

# Поиск в базе данных

Прежде чем идти на вход RETRO, входная последовательность проходит через BERT. Полученные контекстуализированные векторы затем усредняются для построения вектора эмбеддинга предложения. Этот вектор затем используется в качестве запроса к базе данных.

![](https://habrastorage.org/webt/rz/7b/ep/rz7bepnyqckjifabhyvuj7tykxs.png)

*Обработка входной последовательности с помощью BERT'а создает контекстуализированные эмбеддинги токенов. Их усреднение дает эмбеддинг предложения.*

Этот эмбеддинг предложения затем используется в приближенном поиске ближайшего соседа (https://github.com/google-research/google-research/tree/master/scann).

Извлекаются два ближайших соседа, и их текст становится частью входа в RETRO.

![](https://habrastorage.org/webt/9s/zh/kv/9szhkv971n8phe_-wqalfwo10ci.png)

*Эмбеддинг предложения из BERT'а используется для извлечения ближайших соседей из нейронной базы данных RETRO. Затем они добавляются к входным данным языковой модели.*

Теперь это входные данные в RETRO. Входная последовательность и два её ближайших соседа из базы данных (и их продолжения).

Начиная с этого момента блоки Трансформера и RETRO включают в свою обработку фактическую информацию.

![](https://habrastorage.org/webt/p8/wf/pp/p8wfppbxhctradmlnzdwgfgptja.png)

*Полученные соседи добавляются на вход языковой модели. Однако внутри модели они обрабатываются немного по-другому.*

# Высокоуровневая архитектура RETRO

Архитектура RETRO представляет собой стек энкодера и стек декодера.

![](https://habrastorage.org/webt/pv/v7/n7/pvv7n7a5s8bjuaqghwqimea4rbc.png)

*RETRO Трансформер состоит из стека энкодера (для обработки соседей) и стека декодера (для обработки входных данных).*

Энкодер состоит из стандартных блоков энкодера Трансформера (внутреннее внимание (self-attention) + FFNN). Насколько можно судить, RETRO использует энкодер, состоящий из двух блоков энкодера Трансформера.

Стек декодера чередует два типа блоков декодера:

*   Стандартный блок декодера Трансформера (ATTN + FFNN)
*   Блок декодера RETRO (ATTN + Chunked Cross Attention (CCA) + FFNN)

![](https://habrastorage.org/webt/mc/z1/bx/mcz1bx3cyvjjsjz-zdpjnerovo0.png)

*Три типа блоков Трансформера, из которых состоит RETRO.*

Давайте начнем с рассмотрения стека энкодера, который обрабатывает извлеченные соседи, в результате чего получаются матрицы KEYS и VALUES, которые позже будут использоваться в механизме внимания (чтобы освежить знания, см. [Трансформер в картинках](https://habr.com/ru/post/486358/)).

![](https://habrastorage.org/webt/zw/qk/eq/zwqkeqst-x1t2nnoahihj_z_ply.png)

*Стек энкодера обрабатывает извлеченные соседи, в результате чего получаются матрицы KEYS и VALUE.*

Блоки декодера обрабатывают входной текст так же, как GPT. Он применяет внутреннее внимание к токену входа (каузально, поэтому обращает внимание только на предыдущие токены), затем пропускает его через слой FFNN.

![](https://habrastorage.org/webt/3f/mh/l9/3fmhl9umv6uzlewlk0fv2j1ovgs.png)

*Входная последовательность проходит через стандартный блок декодера, содержащий слои внутреннего внимания и FFNN.*

Только достигнув декодера RETRO, мы начнем включать извлеченную фактическую информацию. Каждый третий блок, начиная с 9, является RETRO-блоком (что позволяет его входу обслуживать соседей). Итак, слои 9, 12, 15…32 — это блоки RETRO.

![](https://habrastorage.org/webt/-b/ku/3q/-bku3qe0kjaotkmkvlypne-b-ey.png)

*Входная последовательность достигает блока декодера RETRO, и начинается поиск информации в базе данных.*

Таким образом, на этом шаге модель может найти в извлеченной информации необходимую дату для завершения входной последовательности.

![](https://habrastorage.org/webt/xs/pa/l-/xspal-sqgltgcndlhasai6sc75o.png)

*Блок декодера RETRO извлекает информацию из ближайших соседей с использованием Chunked Cross-Attention.*

# Предыдущие работы

Дополнение языковых моделей методами извлечения информации – активно развивающаяся область исследований. Некоторые из предыдущих работ в этой сфере включают:

*   [Improving Neural Language Models with a Continuous Cache](https://openreview.net/forum?id=B184E5qee)
*   [Generalization through Memorization: Nearest Neighbor Language Models](https://openreview.net/forum?id=HklBjCEKvH)
*   См. [Retrieval Augmented Generation](https://ai.facebook.com/blog/retrieval-augmented-generation-streamlining-the-creation-of-intelligent-natural-language-processing-models/) блог от Meta AI и лекцию Джэки Чи Кит Чонга (Jackie Chi Kit Cheung) на тему [Leveraging External Knowledge in Natural Language Understanding SystemsSPALM: Adaptive Semiparametric Language Models](http://www.crm.umontreal.ca/2018/Langue18/pdf/Cheung.pdf)
*   SPALM: [Adaptive Semiparametric Language Models](https://arxiv.org/abs/2102.02557)
*   DPR: [Dense Passage Retrieval for Open-Domain Question Answering](https://aclanthology.org/2020.emnlp-main.550/)
*   [REALM: Retrieval-Augmented Language Model Pre-Training](https://arxiv.org/abs/2002.08909)
*   FiD: [Leveraging Passage Retrieval with Generative Models for Open Domain Question Answering](https://aclanthology.org/2021.eacl-main.74/)
*   EMDR: [End-to-End Training of Multi-Document Reader and Retriever for Open-Domain Question Answering](https://arxiv.org/abs/2106.05346)
*   BlenderBot 2.0: [Internet-Augmented Dialogue Generation](https://arxiv.org/abs/2107.07566)

# Авторы

* **Автор оригинала** – Jay Alammar
* **Перевод** – [Смирнова Екатерина](https://habr.com/ru/users/smekur/)
* **Редактирование и вёрстка** – [Шкарин Сергей](https://habr.com/ru/users/kouki_rus/)