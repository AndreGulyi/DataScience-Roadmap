Последние достижения в области обработки естественного языка (Natural Language Processing, NLP) в значительной степени основаны на успехах предварительного обучения без учителя, с помощью которого можно обучать универсальные языковые модели на большом количестве текстов без ручной разметки или меток. Было показано, что такие предобученные модели, вроде [BERT](https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html) и [RoBERTa](https://arxiv.org/abs/1907.11692), [запоминают удивительно большое количество общих знаний о мире](https://arxiv.org/pdf/1909.01066.pdf), например «место рождения [Франческо Бартоломео Конти](https://en.wikipedia.org/wiki/Francesco_Bartolomeo_Conti)», «разработчик [JDK](https://en.wikipedia.org/wiki/Java_Development_Kit)» и «владелец [Border TV](https://en.wikipedia.org/wiki/ITV_Border)». Хотя способность кодировать знания особенно важна для определенных задач обработки естественного языка, таких как ответы на вопросы, поиск информации и генерация текста, эти модели запоминают знания неявно, т. е. знания о мире фиксируются абстрактным образом в весах модели, что затрудняет определение, какие знания были сохранены и где именно они хранятся в модели. Кроме того, объем памяти и, следовательно, точность модели ограничены размером нейронной сети. Чтобы получить больше знаний о мире, стандартной практикой является обучение все более крупных сетей, что, однако, может сильно замедлять и удорожать процесс.

Но что если вместо этого существовал бы метод предварительного обучения, позволяющий получить доступ к знаниям явно, например, путем ссылки на дополнительный большой внешний текстовый корпус, способный достичь точных результатов без увеличения или усложнения модели? Например, предложение, найденное во внешней коллекции документов, «Франческо Бартоломео Конти родился во Флоренции», может использоваться моделью для определения места рождения музыканта, вместо того, чтобы полагаться на непрозрачную способность модели получить доступ к знаниям, хранящимся в ее собственных параметрах. Возможность извлекать текст, содержащий явные знания, такие как этот, повысит эффективность предварительного обучения, позволяя модели хорошо работать с наукоемкими задачами без использования миллиардов параметров.

В статье «[REALM: Retrieval-Augmented Language Model Pre-Training](https://arxiv.org/abs/2002.08909)», принятой на [Международной конференции по машинному обучению](https://icml.cc/Conferences/2020) (ICML) 2020 года, авторы рассказали о новой парадигме предварительного обучения языковой модели, которая дополняет модель языкового представления с помощью модуля извлечения знаний, позволяя модели REALM извлекать текстовые знания о мире явно из необработанных текстовых документов вместо запоминания всех знаний в параметрах модели. Авторы также открыли [исходный код REALM](https://github.com/google-research/language/tree/master/language/realm), чтобы продемонстрировать, как можно совместно обучать модуль извлечения и языковое представление.

# Предыстория: предварительное обучение языковых моделей

Чтобы понять, как стандартные языковые модели запоминают общие знания о мире, следует сначала рассмотреть, как эти модели проходят предварительное обучение. С момента изобретения [BERT](https://en.wikipedia.org/wiki/BERT_(language_model)) задача заполнения пропуска, называемая [маскированным языковым моделированием](http://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html) (Masked Language Modeling, MLM), широко использовалась для языковых моделей (или моделей языковых представлений). Задача состоит в заполнении недостающих слов в предложениях, где некоторые слова замаскированы. Пример этой задачи выглядит так:

```
I am so thirsty. I need to __ water. 
Я испытываю жажду. Мне нужно __ воды.
```

Во время предварительного обучения модель просматривает большое количество примеров и настраивает параметры так, чтобы предсказать пропущенные слова (так, в примере выше ответ **drink (выпить)**). Интересно, что задание «заполнить пропуск» заставляет модель запоминать определенные факты об окружающем мире. Например, чтобы заполнить пропущенное слово в следующем примере, необходимо знать место рождения Эйнштейна:

```
Einstein was a __-born scientist. (answer: German)
Эйнштейн был учёным, родившимся в __. (ответ: Германии)
```

Однако, поскольку знания о мире, усвоенные моделью, хранятся в ее весах, они абстрактны, что затрудняет понимание того, какая именно информация была усвоена.

# Идея: предварительное обучение языковой модели с аугментацией извлеченными знаниями

В отличие от стандартных языковых моделей, в REALM добавлен дополнительный модуль извлечения знаний, который сначала извлекает фрагмент текста из коллекции внешних документов в качестве вспомогательных знаний (в своих экспериментах авторы используют [корпус текста Википедии](https://archive.org/details/wikimediadownloads)), а затем передает вспомогательный текст наряду с исходным в языковую модель.

Ключевая интуиция REALM заключается в том, что модуль извлечения знаний должен улучшать способность модели заполнять пропущенные слова. Следовательно, больший вес должны получать те извлеченные тексты, которые предоставляют больше контекста для заполнения пропущенных слов. Если же полученная информация не помогает модели делать прогнозы, её вес следует уменьшить, освобождая место для лучшего извлеченного текста.

Но как обучить модуль извлечения знаний, учитывая, что во время предварительного обучения доступен только неразмеченный текст? Оказывается, можно использовать задачу заполнения слов для обучения модуля извлечения знаний косвенно, без какой-либо ручной разметки. Предположим, есть входной запрос вида:

```
We paid twenty __ at the Buckingham Palace gift shop.
Мы заплатили двадцать __ в сувенирном магазине Букингемского дворца.
```

Заполнить пропущенное слово (ответ: ```pounds``` (```фунты```)) в этом предложении без извлечения знаний может быть непросто, поскольку модели необходимо иметь неявно сохраненные знания о стране, в которой расположен Букингемский дворец, и соответствующей валюте, а также установить связь между ними. Модели было бы легче заполнить пропущенное слово, если бы ей предоставили также фрагмент текста, который бы явно связывал некоторые необходимые знания, извлеченные из внешнего корпуса.

В этом примере следующее предложение получит большой вес в модуле извлечения:

```
Buckingham Palace is the London residence of the British monarchy.
Букингемский дворец - лондонская резиденция британской монархии.
```

Поскольку на данном этапе необходимо добавить больше контекста к исходному предложению, полезными могут оказаться несколько вариантов извлеченных текстов, например вот такой: 

```
The official currency of the United Kingdom is the Pound.
Официальной валютой Соединенного королевства является фунт.
```

Весь процесс показан в следующей схеме:

![image1](https://habrastorage.org/webt/tr/ac/3n/trac3nyjzmtk34yo4exhatmx4hs.gif)

# Вычислительные вызовы для REALM

Большим вызовом для REALM стало масштабирование предварительного обучения, позволяющее модели извлекать знания из миллионов документов. В REALM выбор лучшего документа формулируется как поиск на основе [максимума скалярного произведения](https://papers.nips.cc/paper/5329-asymmetric-lsh-alsh-for-sublinear-time-maximum-inner-product-search-mips.pdf) (Maximum Inner Product Search, MIPS). Для выполнения поиска модели MIPS должны сначала закодировать все документы в коллекции, чтобы каждый документ имел соответствующий вектор. Вход модели кодируется как вектор запроса. В MIPS при заданном запросе извлекается документ в коллекции, имеющий максимальное значение скалярного произведения между вектором документа и вектором запроса, как показано на рисунке ниже:

![image2](https://habrastorage.org/webt/xj/gs/0l/xjgs0lqviliqyo9hhmkdmudswdi.png)

В REALM используется пакет [ScaNN](https://ai.googleblog.com/2020/07/announcing-scann-efficient-vector.html) для эффективного выполнения MIPS, что делает поиск максимального значения скалярного произведения относительно малозатратным, учитывая, что векторы документа предварительно подсчитаны. Однако, если параметры модели были обновлены во время обучения, обычно необходимо перекодировать векторы документов для всей коллекции документов. Для решения этой вычислительной проблемы авторы построили модуль извлечения таким образом, чтобы вычисления, выполняемые для каждого документа, можно было кэшировать и асинхронно обновлять. Авторы также обнаружили, что обновление векторов документов каждые 500 шагов обучения, а не каждый шаг, может обеспечить хорошую производительность и сделать обучение более управляемым.

# Применение REALM к ответам на вопросы в открытой области

Авторы оценили эффективность REALM, применив модель на задаче [ответов на вопросы открытой предметной области](https://en.wikipedia.org/wiki/Question_answering#Open_domain_question_answering) (Open-QA), одной из самых знаниеемких задач в обработке естественного языка. Цель задачи - ответить на такие вопросы, как «Какой угол у равностороннего треугольника?».

В стандартных задачах с ответами на вопросы (например, [SQuAD](https://arxiv.org/abs/1606.05250) или [Natural Questions](https://ai.google.com/research/NaturalQuestions/)) вспомогательный документ предоставляется как часть входных данных, поэтому модели нужно только искать ответ в данном документе. В Open-QA нет заданных документов, поэтому модели должны сами искать знания — это делает Open-QA отличной задачей для проверки эффективности REALM.

На следующем рисунке показаны результаты для Open-QA-версии [Natural Questions](https://ai.googleblog.com/2019/01/natural-questions-new-corpus-and.html). В основном авторы сравнивали свои результаты с [T5](http://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html), другим подходом, который обучает модель без дополнительных размеченных документов. Из рисунка ясно видно, что предварительное обучение REALM генерирует очень мощные модели Open-QA и даже превосходит гораздо более крупную модель T5 (11 млрд) почти на 4 пункта, используя только часть параметров (300 млн).

![image3](https://habrastorage.org/webt/fi/kw/z4/fikwz4n3we7qzn5xqjasfc4ho8i.png)

# Заключение

Выпуск REALM помог повысить интерес к разработке моделей, аугментированных извлеченными текстами, включая недавнюю [генеративную модель](https://arxiv.org/abs/2005.11401). Авторы с нетерпением ждут возможности расширить это направление работы несколькими способами, включая 1) применение методов, подобных REALM, к новым приложениям, требующим знаниеемких ответов и интерпретируемости выхода (помимо Open-QA), и 2) изучение преимуществ извлечения других форм знаний, таких как изображения, структуры графов знаний или даже текста на других языках. Авторы также будут рады наблюдать за работой исследовательского сообщества с открытым [кодом REALM](https://github.com/google-research/language/tree/master/language/realm).

# Авторы

* **Автор оригинала** – Ming-Wei Chang, Kelvin Guu
* **Перевод** – [Смирнова Екатерина](https://habr.com/ru/users/smekur/)
* **Редактирование и вёрстка** – [Шкарин Сергей](https://habr.com/ru/users/kouki_rus/)